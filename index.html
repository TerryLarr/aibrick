<html>
  <head>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands"></script>
	<script src="ble.js"></script>
	<script type="text/javascript">
		// more documentation available at https://github.com/tensorflow/tfjs-models/tree/master/speech-commands
		
		var model_loaded = false;
		var model_url = "";

		async function createModel(url="") {
			if (url){
				const checkpointURL = url + "model.json"; // model topology
				const metadataURL = url + "metadata.json"; // model metadata
				var recognizer = speechCommands.create(
					"BROWSER_FFT", 
					undefined,
					checkpointURL,
					metadataURL);
			} else {
				var recognizer = speechCommands.create("BROWSER_FFT");
			}

			// check that model and metadata are loaded via HTTPS requests.
			await recognizer.ensureModelLoaded();
			model_loaded = true;

			return recognizer;
		}
		
		function get_best_prediction(labels, values){
			var best_label = ''
			var best_value = 0
			for (let i = 0; i < labels.length; i++) {
				if (values[i] > best_value){
					best_value = values[i]
					best_label = labels[i]
				}
			}
			return best_label + '\n'
		}

		async function model_init(url) {
			model_url = url
			const recognizer = await createModel(url);
			const classLabels = recognizer.wordLabels();
			const labelContainer = document.getElementById("label-container");
			labelContainer.replaceChildren();
			for (let i = 0; i < classLabels.length; i++) {
				bar = document.createElement("div");
				bar.id = classLabels[i];
				bar.setAttribute("class", "bar");
				bar.innerHTML = classLabels[i];
				labelContainer.appendChild(bar);
			}

			// listen() takes two arguments:
			// 1. A callback function that is invoked anytime a word is recognized.
			// 2. A configuration object with adjustable fields
			recognizer.listen(result => {
				const scores = result.scores; // probability of prediction for each class
				// render the probability scores per class
				argmax = 0
				for (let i = 0; i < classLabels.length; i++) {
					if (argmax < result.scores[i] && !classLabels[i].startsWith('_')){
						argmax = result.scores[i]
					}
					const classPrediction = classLabels[i] + ":&nbsp;" + result.scores[i].toFixed(2);
					labelContainer.childNodes[i].innerHTML = classPrediction.replace(' ', '&nbsp;');
					width = 200*result.scores[i].toFixed(2)
					labelContainer.childNodes[i].style.width = width.toString() + "px";
					
				}
				if (argmax > 0.75){
					nusSendString(get_best_prediction(classLabels, result.scores));
				}
			}, {
				includeSpectrogram: false, // in case listen should return result.spectrogram
				probabilityThreshold: 0.0,
				invokeCallbackOnNoiseAndUnknown: true,
				overlapFactor: 0.75 // probably want between 0.5 and 0.75. More info in README
			});
		}
	</script>
	<style>
		body {
			font-family: 'Barlow', sans-serif;
		}
		.bar {
			font-size: 10px;
			border-radius: 5px;
			border: 1px solid blue;
			padding: 2px;
			margin: 2px;		
			width: 200px;
			background-color: lightblue;
		}
		.center {
			margin: auto;
			width: 210px;
			padding: 10px;
		}
		#clientConnectButton {
			width: 200px;
		}
	</style>
	<title>Pybricks AI command recognition</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
	<div class="center">
		<button id="clientConnectButton" type="button" onclick="toggleConnection()">Connect to hub</button>
	</div>
	<div id="label-container" class="center"></div>
  </body>
</html>