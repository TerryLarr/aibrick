<html>
  <head>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>
	<script src="ble.js"></script>
	<script type="text/javascript">
		// more documentation available at
		// https://github.com/tensorflow/tfjs-models/tree/master/speech-commands

		async function createModel() {
			const recognizer = speechCommands.create("BROWSER_FFT");

			// check that model and metadata are loaded via HTTPS requests.
			await recognizer.ensureModelLoaded();

			return recognizer;
		}
		
		function get_best_prediction(labels, values){
			var best_label = ''
			var best_value = 0
			for (let i = 0; i < labels.length; i++) {
				value = Math.round(100*values[i].toFixed(2))
				if (value > best_value){
					best_value = value
					best_label = labels[i]
				}
			}
			return best_label + '\n'
		}

		async function init() {
			const recognizer = await createModel();
			const classLabels = recognizer.wordLabels(); // get class labels
			const labelContainer = document.getElementById("label-container");
			for (let i = 0; i < classLabels.length; i++) {
				bar = document.createElement("div");
				bar.id = classLabels[i];
				bar.setAttribute("class", "bar");
				bar.innerHTML = classLabels[i]
				labelContainer.appendChild(bar);
			}

			// listen() takes two arguments:
			// 1. A callback function that is invoked anytime a word is recognized.
			// 2. A configuration object with adjustable fields
			recognizer.listen(result => {
				const scores = result.scores; // probability of prediction for each class
				// render the probability scores per class
				argmax = 0
				for (let i = 0; i < classLabels.length; i++) {
					if (argmax < result.scores[i] && !classLabels[i].startsWith('_')){
						argmax = result.scores[i]
					}
					const classPrediction = classLabels[i] + ":&nbsp;" + result.scores[i].toFixed(2);
					labelContainer.childNodes[i].innerHTML = classPrediction;
					width = 200*result.scores[i].toFixed(2)
					labelContainer.childNodes[i].style.width = width.toString() + "px";
					
				}
				if (argmax > 0.75){
					nusSendString(get_best_prediction(classLabels, result.scores));
				}
			}, {
				includeSpectrogram: false, // in case listen should return result.spectrogram
				probabilityThreshold: 0.0,
				invokeCallbackOnNoiseAndUnknown: true,
				overlapFactor: 0.75 // probably want between 0.5 and 0.75. More info in README
			});
		}
		
		init();
	</script>
	<style>
		body {
			font-family: 'Barlow', sans-serif;
		}
		.bar {
			font-size: 10px;
			border-radius: 5px;
			border: 1px solid blue;
			padding: 2px;
			margin: 2px;		
			width: 200px;
			background-color: lightblue;
		}
		.center {
			margin: auto;
			width: 210px;
			padding: 10px;
		}
		#clientConnectButton {
			width: 200px;
		}
	</style>
	<title>Pybricks AI command recognition</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
	<div class="center">
		<button id="clientConnectButton" type="button" onclick="toggleConnection()">Connect Bluetooth</button>
	</div>
	<div id="label-container" class="center"></div>
  </body>
</html>